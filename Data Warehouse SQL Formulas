# Exrtract CSV table from Blob Storage in Microsoft Fabric and Load into Datawarehouse (ELT concept)

COPY INTO dbo.Region 
FROM 'https://mystorageaccountxxx.blob.core.windows.net/private/Region.csv' WITH ( 
            FILE_TYPE = 'CSV'
            ,CREDENTIAL = ( 
                IDENTITY = 'Shared Access Signature'
                , SECRET = 'xxx'
                )
            ,FIRSTROW = 2
            )
GO

# Meaning for the logic:
COPY INTO dbo.Region: This specifies that data will be copied into the Region table in the dbo schema.
FROM 'https://mystorageaccountxxx.blob.core.windows.net/private/Region.csv': This indicates the source of the data. 
It’s a CSV file located at the provided URL.
FILE_TYPE = 'CSV': Specifies that the file is in CSV format.
CREDENTIAL = (IDENTITY = 'Shared Access Signature', SECRET = 'xxx'): Refers to the credentials needed to access the file. 
In this case, it’s using a shared access signature (SAS) with the provided secret.
FIRSTROW = 2: Indicates that the first row of the CSV file contains column headers, so data extraction should start from the second row.
GO: This is a batch separator in SQL Server. It marks the end of the current batch of statements.

#Skeleton logic for above code
COPY INTO SchemaName.TableName
FROM 'Source_Path.FileFormat' WITH 
(File_Type = '--', Credential = (Identity= '--', Secret = '--'), Firstrow = 2)
GO

----------------------------------------------------------------------

# Pull top 3 employees who draws highest salary

This is written as inner query to retrive all columns (employee .*) in the employee table based on first line logic. 
The second line represents create unique row for each department and sort salary in descending order.
SELECT employees.*,
       ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) AS employee_rank
FROM employees;

Now use both outer query and inner query to retieve top 3 highest salaried employees from each department.
SELECT * FROM (
    SELECT employees.*,
           ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) AS employee_rank
    FROM employees) 
WHERE employee_rank <= 3;

# We can get same result by using different logic

Select * From Employees
Order By Salary DESC
LIMIT 3;

# Retrieve the top 5 employees with the highest salary
SELECT *
FROM employees
ORDER BY salary DESC
LIMIT 5;

-------------------------------------------------------------------------------------------------------------------------------

# Pull the details of employee who earns 2nd highest salary in the department.
# Using Row_number as window function in this scenario.

SELECT *
FROM (
    SELECT employees.*,
           ROW_NUMBER() OVER (ORDER BY salary DESC) AS employee_rank
    FROM employees
)
WHERE employee_rank = 2;

Select * From Employees
Order By Salary DESC
LIMIT 1 OFFSET 1;

# Retrieve employees in batches of 5, starting from the 6th employee (i.e., skip the first 5 employees)
SELECT *
FROM employees
ORDER BY salary DESC
LIMIT 5 OFFSET 5;

# In the same scenario, if we give Limit 10 Offset 5, then out of total 15 rows the output results skips first 5 rows 
and pulls the data from row number 6 to row number 14 by skipping first 5 rows.

# In the same logic if we set Limit to 5 and offset to 10, then the final results pull total 5 rows in data table
from row 11 to row 15 by skipping first 10 rows.
-------------------------------------------------------------------------------------------------------------------------------------
# Find employees who draws same salary
Use Dense_Rank as Window function.
SELECT *
FROM (
    SELECT employees.*,
           DENSE_RANK() OVER (ORDER BY salary DESC) AS employee_rank
    FROM employees
)
WHERE employee_rank = 2;

----------------------------------------------------------------------------------------------------------------------------------------
 

# Pull first 10 employees in SQL server.

SELECT TOP 10 * FROM Employees
ORDER BY Salary DESC;

# In ORACLE we should use Row_Number clause to pull same results
-------------------------------------------------------------------------------------------------------------------------

# Delete duplicate records of Employees in employee table

Below is a wrong logic with Where cluase which gives ERROR result.
Select First_Name, Last_Name, Country, Count(*) From Employees
Where Count(*) > 1;

Below is the correct logic with Group By and Having Cluase
Select FirstName, LastName, Country, Count(*) From Employees
Group By FirstName, LastName, Country
Having Count(*) > 1;
----------------------------------------------------------------------------------------------------------------------------

# Delete Duplicate records of employees based on Employee_IDs in Employee table

# First Create CTE (Custom Table Expression) 
Select Employees.*,
Row_Number() Over(Partition By FirstName, LastName, Country Order By EmployeeID) as Row_Number
From Employees;

# Now write the logic
With CTE AS 
(Select Employees.*,
Row_Number() Over(Partition By FirstName, LastName, Country Order By EmployeeID) as Row_Number
From Employees)
Delete From CTE WHERE Row_Number>1;

# Let’s break down the query to understand why we explicitly list the columns instead of using e.* in the Common Table Expression (CTE).

Column Selection in CTE:
In the CTE, we explicitly specify the columns [FirstName], [LastName], and [Country]. 
This is intentional because we want to create a temporary result set with only these specific columns.
By doing so, we ensure that the subsequent DELETE operation affects only these columns and doesn’t inadvertently impact other columns in the table.

# Using e.* in CTE:
While it’s possible to use e.* (which would represent all columns from the Employee table) in the CTE, it’s generally better to be explicit about the columns you’re working with.
Using e.* might lead to unintended consequences if there are additional columns in the Employee table that you don’t want to include in the CTE or affect during the deletion process.
Explicitly listing the columns provides better control over the data you’re manipulating.

SELECT employees.*,
           ROW_NUMBER() OVER (ORDER BY salary DESC) AS employee_rank
FROM employees



# Considerations:
If you want to include all columns from the Employee table in the CTE, you can certainly use e.*. However, be cautious and ensure that all columns are relevant to your task.
If you only need specific columns (as in our example), explicitly listing them is a good practice for clarity and maintainability.
Remember that the choice between specifying individual columns and using e.* depends on your specific requirements and the context of your query
