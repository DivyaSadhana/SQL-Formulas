# Exrtract CSV table from Blob Storage in Microsoft Fabric and Load into Datawarehouse (ELT concept)

COPY INTO dbo.Region 
FROM 'https://mystorageaccountxxx.blob.core.windows.net/private/Region.csv' WITH ( 
            FILE_TYPE = 'CSV'
            ,CREDENTIAL = ( 
                IDENTITY = 'Shared Access Signature'
                , SECRET = 'xxx'
                )
            ,FIRSTROW = 2
            )
GO

# Meaning for the logic:
COPY INTO dbo.Region: This specifies that data will be copied into the Region table in the dbo schema.
FROM 'https://mystorageaccountxxx.blob.core.windows.net/private/Region.csv': This indicates the source of the data. 
It’s a CSV file located at the provided URL.
FILE_TYPE = 'CSV': Specifies that the file is in CSV format.
CREDENTIAL = (IDENTITY = 'Shared Access Signature', SECRET = 'xxx'): Refers to the credentials needed to access the file. 
In this case, it’s using a shared access signature (SAS) with the provided secret.
FIRSTROW = 2: Indicates that the first row of the CSV file contains column headers, so data extraction should start from the second row.
GO: This is a batch separator in SQL Server. It marks the end of the current batch of statements.

#Skeleton logic for above code
COPY INTO SchemaName.TableName
FROM 'Source_Path.FileFormat' WITH 
(File_Type = '--', Credential = (Identity= '--', Secret = '--'), Firstrow = 2)
GO

----------------------------------------------------------------------

# Pull top 3 employees who draws highest salary

This is written as inner query to retrive all columns (employee .*) in the employee table based on first line logic. 
The second line represents create unique row for each department and sort salary in descending order.
SELECT employees.*,
       ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) AS employee_rank
FROM employees;

Now use both outer query and inner query to retieve top 3 highest salaried employees from each department.
SELECT * FROM (
    SELECT employees.*,
           ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) AS employee_rank
    FROM employees) 
WHERE employee_rank <= 3;

# We can get same result by using different logic

Select * From Employees
Order By Salary DESC
LIMIT 3;

# Retrieve the top 5 employees with the highest salary
SELECT *
FROM employees
ORDER BY salary DESC
LIMIT 5;

-------------------------------------------------------------------------------------------------------------------------------

# Pull the details of employee who earns 2nd highest salary in the department.
# Using Row_number as window function in this scenario.

SELECT *
FROM (
    SELECT employees.*,
           ROW_NUMBER() OVER (ORDER BY salary DESC) AS employee_rank
    FROM employees
)
WHERE employee_rank = 2;

Select * From Employees
Order By Salary DESC
LIMIT 1 OFFSET 1;

# Retrieve employees in batches of 5, starting from the 6th employee (i.e., skip the first 5 employees)
SELECT *
FROM employees
ORDER BY salary DESC
LIMIT 5 OFFSET 5;

# In the same scenario, if we give Limit 10 Offset 5, then out of total 15 rows the output results skips first 5 rows 
and pulls the data from row number 6 to row number 14 by skipping first 5 rows.

# In the same logic if we set Limit to 5 and offset to 10, then the final results pull total 5 rows in data table
from row 11 to row 15 by skipping first 10 rows.
-------------------------------------------------------------------------------------------------------------------------------------
# Find employees who draws same salary
Use Dense_Rank as Window function.
SELECT *
FROM (
    SELECT employees.*,
           DENSE_RANK() OVER (ORDER BY salary DESC) AS employee_rank
    FROM employees
)
WHERE employee_rank = 2;

----------------------------------------------------------------------------------------------------------------------------------------
 

# Pull first 10 employees in SQL server.

SELECT TOP 10 * FROM Employees
ORDER BY Salary DESC;

# In ORACLE we should use Row_Number clause to pull same results
-------------------------------------------------------------------------------------------------------------------------

# Identify duplicate records of Employees in employee table

Below is a wrong logic with Where cluase which gives ERROR result.
Select First_Name, Last_Name, Country, Count(*) From Employees
Where Count(*) > 1;

Below is the correct logic with Group By and Having Cluase
Select FirstName, LastName, Country, Count(*) From Employees
Group By FirstName, LastName, Country
Having Count(*) > 1;
----------------------------------------------------------------------------------------------------------------------------
# Delete duplicate records in the table
DELETE FROM Employees
WHERE (FirstName, LastName, Country) IN (
    SELECT FirstName, LastName, Country, Count(*)
    FROM Employees
    GROUP BY FirstName, LastName, Country
    HAVING COUNT(*) > 1
);

--------------------------------------------------------------------------------------------------------------------------

# Delete Duplicate records of employees based on Employee_IDs in Employee table

# First Create CTE (Custom Table Expression) 
Select Employees.*,
Row_Number() Over(Partition By FirstName, LastName, Country Order By EmployeeID) as Row_Number
From Employees;

# Now write the logic
With CTE AS 
(Select Employees.*,
Row_Number() Over(Partition By FirstName, LastName, Country Order By EmployeeID) as Row_Number
From Employees)
Delete From CTE WHERE Row_Number>1;

# Let’s break down the query to understand why we explicitly list the columns instead of using e.* in the Common Table Expression (CTE).

Column Selection in CTE:
In the CTE, we explicitly specify the columns [FirstName], [LastName], and [Country]. 
This is intentional because we want to create a temporary result set with only these specific columns.
By doing so, we ensure that the subsequent DELETE operation affects only these columns and doesn’t inadvertently impact other columns in the table.

# Using e.* in CTE:
While it’s possible to use e.* (which would represent all columns from the Employee table) in the CTE, it’s generally better to be explicit about the columns you’re working with.
Using e.* might lead to unintended consequences if there are additional columns in the Employee table that you don’t want to include in the CTE or affect during the deletion process.
Explicitly listing the columns provides better control over the data you’re manipulating.

SELECT employees.*,
           ROW_NUMBER() OVER (ORDER BY salary DESC) AS employee_rank
FROM employees



# Considerations:
If you want to include all columns from the Employee table in the CTE, you can certainly use e.*. However, be cautious and ensure that all columns are relevant to your task.
If you only need specific columns (as in our example), explicitly listing them is a good practice for clarity and maintainability.
Remember that the choice between specifying individual columns and using e.* depends on your specific requirements and the context of your query

----------------------------------------------------------------------------------------
# How to handle null values

1. Filtering with NULL Values:
Use the IS NULL or IS NOT NULL operators to filter rows based on null values.
Avoid using comparison operators (=, !=, <, >, etc.) with nulls, as they will not work as expected.

2. Coalescing NULL Values:
Use the COALESCE() function to replace nulls with a default value.
For example: SELECT COALESCE(column_name, 'default_value') FROM table_name;

3. Conditional Logic:
Use the CASE statement to handle nulls in a conditional logic.
For example:
SQL

SELECT CASE 
           WHEN column_name IS NULL THEN 'default_value' 
           ELSE column_name 
       END 
FROM table_name;
---------------------------------------------------------------------------------------------------------------------------------
# Write a query to fetch employees who joined in last 30days
The DATEADD function subtracts 30 days from the current date, which is obtained by GETDATE(), to find employees who joined in this period.

Select * From Employees
Where JOINING_DATE >= DATEADD(DAY, -30, GETDATE());

---------------------------------------------------------------------------------------------------------------------------------
1. Replace row level data based on specific single identifier.

update [Vaccines].[dbo].[PATIENT_IDENTIFIERS_DATA]
set DEATH= 'N' where DEATH is null;

2. Replace null values of rows with 2 different values. 
#Rename data as'No' for multiple columns in which only 2 data types are available where 'Y' or N'.

UPDATE [Vaccines].[dbo].[PATIENT_IDENTIFIERS_DATA]
SET 
    LIFE_THREATENING = CASE WHEN LIFE_THREATENING IS NULL THEN 'N' ELSE LIFE_THREATENING END,
    HOSPITALIZATION = CASE WHEN HOSPITALIZATION IS NULL THEN 'N' ELSE HOSPITALIZATION END,
	PROLONGED_HOSPITALIZATION = case when PROLONGED_HOSPITALIZATION is null then 'N' else PROLONGED_HOSPITALIZATION end,
	DISABLITY = case when DISABLITY is null then 'N' else DISABLITY end,
	BIRTH_DEFECT = case when BIRTH_DEFECT is null then 'N' else BIRTH_DEFECT,	
	ALLERGIES_HISTORY = case when ALLERGIES_HISTORY is null then 'None' else ALLERGIES_HISTORY end;

3. Replace the row level data having 3 different values (1, 0, Null) as (Yes, No, Unknown) respectively for a single column.
# Create a new column with 'case when' logic based on the data from old column. Then delete the old column from the table.

ALTER TABLE [Vaccines].[dbo].[PATIENT_IDENTIFIERS_DATA]
ADD RECOVERED_FROM_ADVERSE_EVENT VARCHAR(2);

UPDATE [Vaccines].[dbo].[PATIENT_IDENTIFIERS_DATA]
SET RECOVERED_FROM_ADVERSE_EVENT = CASE 
                    WHEN RECOVERED = 1 THEN 'Y'
                    WHEN RECOVERED = 0 THEN 'N'
                    ELSE NULL
                END;

ALTER TABLE [Vaccines].[dbo].[PATIENT_IDENTIFIERS_DATA]
drop column RECOVERED;
----------------------------------------------------------------------------------------------------------------------------
